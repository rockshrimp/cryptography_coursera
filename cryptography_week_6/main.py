import gmpy2

n_1 = gmpy2.mpz('17976931348623159077293051907890247336179769789423065727343008115\
77326758055056206869853794492129829595855013875371640157101398586\
47833778606925583497541085196591615128057575940752635007475935288\
71082364994994077189561705436114947486504671101510156394068052754\
0071584560878577663743040086340742855278549092581')


def question_1(n):
    a = gmpy2.isqrt_rem(n)[0] + 1
    x = gmpy2.isqrt(a ** 2 - n)

    p = a - x
    q = a + x

    min_factor = min(p, q)
    print(f'min(p,q) : {min_factor}')
    return p, q


n_2 = gmpy2.mpz('6484558428080716696628242653467722787263437207069762630604390703787 \
9730861808111646271401527606141756919558732184025452065542490671989 \
2428844841839353281972988531310511738648965962582821502504990264452 \
1008852816733037111422964210278402893076574586452336833570778346897 \
15838646088239640236866252211790085787877')


def question_2(n):
    sqrt_n = gmpy2.isqrt_rem(n)[0] + 1
    upper_bound = sqrt_n + 2 ** 20
    for a in range(sqrt_n, upper_bound):
        x, r = gmpy2.isqrt_rem(a ** 2 - n)
        if r == 0:
            p = a - x
            q = a + x

            min_factor = min(p, q)
            print(f'min(p,q) : {min_factor}')
            return min_factor


n_3 = gmpy2.mpz('72006226374735042527956443552558373833808445147399984182665305798191 \
63556901883377904234086641876639384851752649940178970835240791356868 \
77441155132015188279331812309091996246361896836573643119174094961348 \
52463970788523879939683923036467667022162701835329944324119217381272 \
9276147530748597302192751375739387929')


def question_3(n):

    d, r = gmpy2.isqrt_rem(6 * n)
    A = d + 1 if r > 0 else 0
    # M = (3p + 2q) / 2
    # 3p = M + i - 0.5 = A + i - 1
    # 2q = M - i + 0.5 = A - i

    # i ^ 2 - i = A ^ 2 - A - 6
    # 6N = A^2 - i^2 - A + i
    # i^2 - i + A^2 - A - 6N
    a = 1
    b = -1
    c = -((A**2) - A - (6*n))

    roots = [gmpy2.div(- b - gmpy2.isqrt(b**2 - 4*a*c), 2*a),
             gmpy2.div(- b + gmpy2.isqrt(b**2 - 4*a*c), 2*a)]

    for root in roots:
        p = gmpy2.div(A + root - 1, 3)
        q = gmpy2.div(A - root, 2)

        if gmpy2.mul(p,q) == n:
            min_factor = min(p, q)
            print(f'min(p,q) : {min_factor}')
            return min_factor


challenge_ciphertext = gmpy2.mpz('220964518674103817763065611348834180174100697878928310717318391436761\
        3560012053800428232965047350942434394621975151225646583996794288946076454204\
        0581564748988013734864120452325229320176487916666402997509188729971690526083\
        2220677716000193292608700095799937240774589677736978175712672299511486629596\
        27934791540')


def question_4(n, ciphertext):
    e = 65537
    p, q = question_1(n_1)
    phi = gmpy2.mul((p-1), (q-1))
    d = gmpy2.invert(e, phi)
    pkcs_encrypted_plaintext = gmpy2.powmod(ciphertext, d, n)

    # Now that we've decrypted the RSA encryption we treat the PKCS encoding
    # We convert the integer to a string and look for the separator \x00
    pkcs_string = "".join([chr(pkcs_encrypted_plaintext[i:i + 8]) for i in range(0, len(pkcs_encrypted_plaintext), 8)])
    separator_position = pkcs_string.find(chr(0))

    print(pkcs_string[:separator_position][::-1])


if __name__ == '__main__':

    question_1(n_1)
    # 13407807929942597099574024998205846127479365820592393377723561443721764030073662768891111614362326998675040546094339320838419523375986027530441562135724301

    question_2(n_2)
    # 25464796146996183438008816563973942229341454268524157846328581927885777969985222835143851073249573454107384461557193173304497244814071505790566593206419759

    question_3(n_3)
    # 21909849592475533092273988531583955898982176093344929030099423584127212078126150044721102570957812665127475051465088833555993294644190955293613411658629209
    
    question_4(n_1, challenge_ciphertext)
    # Factoring lets us break RSA.
